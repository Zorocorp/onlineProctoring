useEffect(() => {
    if (openSuccessDialog && testId) {
        axios.get(`${API_BASE_URL}/get-secure-uuid/${testId}/`)

        .then((res) => {
          const encodedUuid = res.data.encoded_uuid;
          setTestLink(`${BASE_URL}/${encodedUuid}`);
        })
        .catch((err) => {
          console.error("Failed to fetch secure test UUID", err);
        });
    }
  }, [openSuccessDialog, testId]);
  useEffect(() => {
    const fetchQuestions = async () => {
      const userToken = localStorage.getItem("user_token");
      if (!userToken) {
        console.error("No user token found");
        return;
      }

      try {
        const response = await axios.get(`${API_BASE_URL}/questions/`, {
          headers: {
            "Authorization": `Token ${userToken}`
          }
        });
        setFetchedQuestions(response.data);
      } catch (error) {
        console.error("Error fetching questions:", error);
      }
    };

    fetchQuestions();
  }, []);

  const handleCloseImportModal = () => setModalOpen(false);
  const handleCorrectAnswersChange = (qIndex, optionIndex) => {
    const updatedQuestions = [...questions];
    let correctAnswers = updatedQuestions[qIndex].correctAnswers || [];

    const optionValue = updatedQuestions[qIndex].options[optionIndex]; // Get the actual option text

    if (correctAnswers.includes(optionValue)) {
        // Remove answer if already selected
        correctAnswers = correctAnswers.filter(answer => answer !== optionValue);
    } else {
        // Add the answer text
        correctAnswers.push(optionValue);
    }

    updatedQuestions[qIndex].correctAnswers = correctAnswers; // Store values, not indexes
    setQuestions(updatedQuestions);
};
  const handleNext = async () => {
    // Check if all required fields are filled in case 0
    if (activeStep === 0) {
      if (!testName || !testDescription || !category || !subject || !difficulty) {
        alert("Please fill in all fields before proceeding.");
        return;
      }
    }

    // Check if there are questions before moving to the next step
    if (activeStep === 1) {
      if (questions.length === 0) {
        alert("Please create at least one question before proceeding.");
        return;
      }
    }

    // Proceed to the next step
    if (activeStep === steps.length - 1) {
      setLoading(true);
      await handleSubmit();
      setOpenSuccessDialog(true);
    } else {
      setActiveStep((prevStep) => prevStep + 1);
    }
  };
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
    alert("Test link copied!");
  };
  const handleCSVUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      Papa.parse(file, {
        complete: (results) => {
          const emails = results.data
            .map((row) => row[0]?.trim())
            .filter((email) => email && /\S+@\S+\.\S+/.test(email)); // Basic email check
          setEmailList(emails);
        },
      });
    }
  };

  const handleSaveAndSendEmails = async () => {
    if (!testId || emailList.length === 0) {
      alert("Please upload a valid CSV and ensure test ID is set.");
      return;
    }
    const userToken = localStorage.getItem("user_token");
    try {
      setLoading(true);
 
      const response = await fetch(`${API_BASE_URL}/upload-allowed-emails/`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Token ${userToken}` // ✅ If you’re using token-based auth
        },
        body: JSON.stringify({
          test_id: testId,
          emails: emailList
        })
      });
 
      const data = await response.json();
      console.log("✅ Email upload response:", data);
 
      if (response.ok) {
        alert("Emails uploaded and invitations sent!");
      } else {
        console.error("❌ Upload failed:", data);
        alert(data.error || "Failed to send emails.");
      }
    } catch (error) {
      console.error("❌ Error sending emails:", error);
      alert("An unexpected error occurred.");
    } finally {
      setLoading(false);
    }
  };
 
  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
  };

const addTrueFalseQuestion = () => {
  setQuestions(prevQuestions => [
    ...prevQuestions,
    { type: "truefalse", text: "Is this statement true or false?", correctAnswer: null },
  ]);
  setTotalQuestions(prevTotal => prevTotal + 1);
  setTotalMarks(prevMarks => prevMarks + marksPerQuestion);
};

const addMultipleChoiceQuestion = () => {
  setQuestions(prevQuestions => [
    ...prevQuestions,
    { type: "multiplechoice", text: "", options: ["", "", "", ""], correctAnswer: "" },
  ]);
  setTotalQuestions(prevTotal => prevTotal + 1);
  setTotalMarks(prevMarks => prevMarks + marksPerQuestion);
};

const addFillInTheBlankQuestion = () => {
  setQuestions(prevQuestions => [
    ...prevQuestions,
    { type: "fillintheblank", text: "____ is the capital of France.", correctAnswer: "" },
  ]);
  setTotalQuestions(prevTotal => prevTotal + 1);
  setTotalMarks(prevMarks => prevMarks + marksPerQuestion);
};

const addMultipleResponseQuestion = () => {
  setQuestions(prevQuestions => [
    ...prevQuestions,
    { type: "multipleresponse", text: "", options: ["", "", "", ""], correctAnswers: [] },
  ]);
  setTotalQuestions(prevTotal => prevTotal + 1);
  setTotalMarks(prevMarks => prevMarks + marksPerQuestion);
};
  const handleQuestionTextChange = (index, value) => {
    const newQuestions = [...questions];
    newQuestions[index].text = value;
    setQuestions(newQuestions);
  };
    const handleLogout = () => { // Clear any stored authentication data, tokens, etc.
    localStorage.removeItem("user_token"); // Example: Remove an auth token
    alert("You have been logged out.");
    navigate("/login");
  };
  const handleOptionChange = (qIndex, optionIndex, value) => {
    const newQuestions = [...questions];
    if (value === "") {
      newQuestions[qIndex].options = newQuestions[qIndex].options.filter((_, index) => index !== optionIndex);
    } else {
      newQuestions[qIndex].options[optionIndex] = value;
    }
    setQuestions(newQuestions);
  };
  const handleCorrectAnswerChange = (qIndex, value) => {
    // Create a copy of the current questions state
    const updatedQuestions = [...questions];

    // Check if the question exists
    if (updatedQuestions[qIndex]) {
        const questionType = updatedQuestions[qIndex].type;

        if (questionType === "multiplechoice") {
            // For multiple choice, value should be the index of the selected option
            updatedQuestions[qIndex].correctAnswer = value; // Store the index of the selected option
        } else if (questionType === "truefalse") {
            // For true/false, value should be a boolean
            updatedQuestions[qIndex].correctAnswer = value; // Store the boolean value
        }

        setQuestions(updatedQuestions); // Update the state with the new questions array
        console.log(`Question ${qIndex}, Selected Answer: ${updatedQuestions[qIndex].correctAnswer}`); // Log the selected answer
    } else {
        console.error(`Question at index ${qIndex} does not exist.`);
    }
};
const handleCorrectAnswerChanges = (qIndex, optionIndex) => {
  console.log(`Question ${qIndex}, Selected Option: ${optionIndex}`);
  const updatedQuestions = [...questions];
  let correctAnswers = updatedQuestions[qIndex].correctAnswers || []; // Ensure correctAnswers is initialized

  const optionValue = updatedQuestions[qIndex].options[optionIndex];  // Get answer text

  if (correctAnswers.includes(optionValue)) {
      // Remove answer if already selected
      correctAnswers = correctAnswers.filter(answer => answer !== optionValue);
  } else {
      // Add the answer text
      correctAnswers.push(optionValue);
  }

  updatedQuestions[qIndex].correctAnswers = correctAnswers;  // Store values, not indexes
  setQuestions(updatedQuestions);
};

const handleQuestionSelect = (question) => {
    setSelectedQuestions((prevQuestions) => {
        const isAlreadySelected = prevQuestions.some(q => q.id === question.id);
        if (isAlreadySelected) {
            return prevQuestions.filter(q => q.id !== question.id);
        } else {
            return [...prevQuestions, question];
        }
    });
};
  const handleFillInTheBlankAnswerChange = (qIndex, value) => {
    const newQuestions = [...questions];
    newQuestions[qIndex].correctAnswer = value;
    setQuestions(newQuestions);
  };
   const handleAddOption = (qIndex) => {
    const updatedQuestions = [...questions];
    updatedQuestions[qIndex].options.push(newOption);
    setQuestions(updatedQuestions);
    setNewOption(""); // Reset input field
  };

  const handleRemoveQuestion = (qIndex) => {
    const updatedQuestions = questions.filter((_, index) => index !== qIndex);
    setQuestions(updatedQuestions);
    setTotalQuestions(totalQuestions - 1);
    setTotalMarks(totalQuestions - 1 * marksPerQuestion);
  };
const handleFileChange = (e) => {
    setFile(e.target.files[0]);
    setSuccess(null);
    setError(null);
};

const handleSubmit = async () => {
    const userToken = localStorage.getItem("user_token");
    setLoading(true);

    try {
        const totalQuestionsCount = questions.length + selectedQuestions.length;
        const totalTimeLimit = totalQuestionsCount * timeLimitPerQuestion;

        const testData = {
            title: testName,
            description: testDescription,
            category,
            max_score: totalQuestionsCount * marksPerQuestion,
            total_marks: totalQuestionsCount * marksPerQuestion,
            subject,
            difficulty,
          
            time_limit_per_question: timeLimitPerQuestion,
            total_time_limit: totalTimeLimit / 60,
            marks_per_question: marksPerQuestion,
            pass_criteria: passCriteria,
            instructions,
            conclusion,
            scheduled_date: null,
            is_public: IsPublic,
            allow_retakes: allowRetakes,
            number_of_retakes: numberOfRetakes,
            randomize_order: false,
            allow_blank_answers: false,
            penalize_incorrect_answers: false,
            allow_jump_around: false,
            only_move_forward: false,
            indicate_correctness: false,
            display_correct_answer: false,
            show_explanation: false,
            move_on_without_feedback: false,
            show_score: false,
            show_test_outline: false,
            disable_right_click: false,
            disable_copy_paste: false,
            disable_translate: false,
            disable_autocomplete: false,
            disable_spellcheck: false,
            disable_printing: false,
            receive_email_notifications: receiveEmailNotifications,
            notification_emails: notificationEmails,
            start_date: startDate || null,
            end_date: endDate || null,
            due_time: dueTime || null,
            status: "published",
            rank: 1,
            questions: [
                ...questions.map((question) => ({
                    text: question.text,
                    type: question.type,
                    options: question.options ?? [],
                    correct_answer:
                        question.type === "multipleresponse"
                            ? question.correctAnswers
                            : question.correctAnswer ?? "N/A",
                })),
                ...selectedQuestions.map((question) => ({
                    text: question.text,
                    type: question.type,
                    options: question.options ?? [],
                    correct_answer:
                        question.type === "multipleresponse"
                            ? question.correctAnswers
                            : question.correctAnswer ?? "N/A",
                })),
            ],
        };

        // Step 1: Create the test
        console.log("Sending testData:", JSON.stringify(testData, null, 2));
        const response = await axios.post(
            `${API_BASE_URL}/tests/`,
            testData,
            {
                headers: {
                    "Content-Type": "application/json",
                    Authorization: `Token ${userToken}`,
                },
            }
        );

        const newTestId = response.data.id;
        setTestId(newTestId); // Save test ID to state

        // Step 2: Upload file if selected
        if (file) {
            const formData = new FormData();
            formData.append("file", file);
            formData.append("test_id", newTestId);

            await axios.post(
                `${API_BASE_URL}/questions/upload/`,
                formData,
                {
                    headers: {
                        Authorization: `Token ${userToken}`,
                    },
                }
            );
        }

        setSuccess("Test and questions uploaded successfully!");
        setFile(null); // Clear file
        setOpenSuccessDialog(true);
    } catch (error) {
        console.error("Error creating test or uploading questions:", error);
        setError(error.response?.data?.error || "Something went wrong.");
    } finally {
        setLoading(false);
    }
};

    const saveQuestions = async (createdTestId) => {
        const userToken = localStorage.getItem("user_token");
   
        try {
            for (const question of questions) {
                // Ensure options are provided and not empty
                const questionData = {
                    text: question.text,
                    type: question.type,
                    options: question.options, // Ensure options is an array
                    correct_answer: question.type === "multipleresponse" ? question.correctAnswers : question.correctAnswer,
                    test: createdTestId // Associate the question with the test
                };
   
                // Check if the question type requires options
                if ((question.type === "multiplechoice" || question.type === "multipleresponse") && questionData.options.length === 0) {
                    alert("Please provide options for the question.");
                    return; // Prevent saving if options are missing
                }
   
                // Make the API call to save the question
                const response = await axios.post(
                    `${API_BASE_URL}/questions/`,
                    questionData,
                    {
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Token ${userToken}` // Include the token in the header
                        },
                    }
                );
   
                console.log("Question saved:", response.data); // Debugging log
            }
            alert("Questions saved successfully!"); // Feedback to the user
        } catch (error) {
            if (error.response) {
                console.error("Submission failed:", error.response.data);
                alert(`Error: ${JSON.stringify(error.response.data)}`); // Log the error response
            } else {
                console.error("Submission failed:", error.message);
                alert("Error: Unable to connect to the server.");
            }
        }
    };
